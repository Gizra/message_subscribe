<?php

/**
 * @file
 * Subscribe API for the Message and Message notify modules.
 */

use Drupal\message\MessageInterface;

/**
 * Process a message, and send to subscribed users.
 *
 * @param $entity_type
 *   The entity type.
 * @param $entity
 *   The entity object.
 * @param $message
 *   The Message object.
 * @param $notify_options
 *   Optional; Array of options to pass to message_notify_send_message()
 *   keyed by the notifier name.
 * @param $subscribe_options
 *   Optional;
 * @param $context
 * @return Message
 *  The message object.
 */
function message_subscribe_send_message($entity_type, $entity, Message $message, $notify_options = array(), $subscribe_options = array(), $context = array()) {
  $use_queue = isset($subscribe_options['use queue']) ? $subscribe_options['use queue'] : \Drupal::config('message_subscribe.settings')->get('use_queue');
  $notify_message_owner = isset($subscribe_options['notify message owner']) ? $subscribe_options['notify message owner'] : \Drupal::config('message_subscribe.settings')->get('notify_own_actions');

  // Save message by default.
  $subscribe_options += array(
    'save message' => TRUE,
    'skip context' => FALSE,
    'last uid' => 0,
    'uids' => array(),
    'range' => $use_queue ? 100 : FALSE,
    'end time' => FALSE,
    'use queue' => $use_queue,
    'queue' => FALSE,
    'entity access' => TRUE,
    'notify blocked users' => FALSE,
    'notify message owner' => $notify_message_owner,
  );

  if (empty($message->mid) && $subscribe_options['save message']) {
    $message->save();
  }

  if ($use_queue) {
    $queue = DrupalQueue::get('message_subscribe');
    list($id) = entity_extract_ids($entity_type, $entity);
  }

  if ($use_queue && empty($subscribe_options['queue'])) {
    if (empty($message->mid)) {
      throw new Exception('Cannot add a non-saved message to the queue.');
    }

    // Get the context once, so we don't need to process it every time
    // a worker claims the item.
    $context = $context ? $context : message_subscribe_get_basic_context($entity_type, $entity, $subscribe_options, $context);

    $subscribe_options['skip context'] = TRUE;

    // Add item to the queue.
    $task = array(
      'mid' => $message->mid,
      'entity_type' => $entity_type,
      'entity_id' => $id,
      'notify_options' => $notify_options,
      'subscribe_options' => $subscribe_options,
      'context' => $context,
      // Add the user ID for the queue.
      'uid' => $subscribe_options['last uid'],
    );

    // Exit now, as messages will be processed via queue API.
    return $queue->createItem($task);
  }

  $message->message_subscribe = array();

  // Retrieve all users subscribed.
  $uids = array();
  if ($subscribe_options['uids']) {
    // We got a list of user IDs directly from the implementing module,
    // However we need to adhere to the range.
    $uids = $subscribe_options['range'] ? array_slice($subscribe_options['uids'], 0, $subscribe_options['range'], TRUE) : $subscribe_options['uids'];
  }

  if (empty($uids) && !$uids = message_subscribe_get_subscribers($entity_type, $entity, $message, $subscribe_options, $context)) {
    // If we use a queue, it will be deleted.
    return $message;
  }

  foreach ($uids as $uid => $values) {
    $last_uid = $uid;
    // Clone the message in case it will need to be saved, it won't
    // overwrite the existing one.
    $cloned_message = clone $message;
    // Push a copy of the original message into the new one.
    $cloned_message->original = $message;
    unset($cloned_message->mid);
    $cloned_message->uid = $uid;

    $values += array('notifiers' => array());

    // Send the message using the required notifiers.
    foreach ($values['notifiers'] as $notifier_name) {
      $options = !empty($notify_options[$notifier_name]) ? $notify_options[$notifier_name] : array();
      $options += array(
        'save on fail' => FALSE,
        'save on success' => FALSE,
      );

      message_notify_send_message($cloned_message, $options, $notifier_name);

      // Check we didn't timeout.
      if ($use_queue && $subscribe_options['queue']['end time'] && time() < $subscribe_options['queue']['end time']) {
        continue 2;
      }
    }
  }

  if ($use_queue) {
    // Add item to the queue.
    $task = array(
      'mid' => $message->mid,
      'entity_type' => $entity_type,
      'entity_id' => $id,
      'notify_options' => $notify_options,
      'subscribe_options' => $subscribe_options,
      'context' => $context,
      'uid' => $last_uid,
    );

    $task['subscribe_options']['last uid'] = $last_uid;

    // Create a new queue item, with the last user ID.
    $queue->createItem($task);
  }

  return $message;
}

/**
 * Implements hook_message_subscribe_get_subscribers().
 *
 * @param $context
 *   Array keyed with the entity type and array of entity IDs as the
 *   value. According to this context this function will retrieve the
 *   related subscribers.
 * @param $message
 *   The message object.
 *
 * @return
 *   Array keyed with the user ID and the value:
 *   - "flags": Array with the flag names that resulted with including
 *   the user.
 *   - "notifiers": Array with the Message notifier name plugins.
 *
 * @see flag_get_content_flags()
 */
function message_subscribe_message_subscribe_get_subscribers(MessageInterface $message, $subscribe_options = array(), $context = array()) {
  $uids = array();

  $subscribe_options += array(
    'last uid' => 0,
    'range' => FALSE,
  );

  // Determine if a range is needed for the query.
  $range = $subscribe_options['range'];

  // Find the users that subscribed to each context.
  foreach ($context as $entity_type => $entity_ids) {
    if (!$entity_ids) {
      continue;
    }

    // Get all flags on given entity type.
    if (!$flags = message_subscribe_flag_get_flags($entity_type)) {
      continue;
    }

    $fids = array();
    foreach ($flags as $flag) {
      $fids[$flag->id()] = $flag->label();
    }

    // Query all the entity IDs inside the given flags. We don't use
    // flag_get_content_flags() as we want to get all the flaggings of an
    // entity-type in a single query.
    if (FLAG_API_VERSION == 2) {
      $query = db_select('flag_content', 'fc')
        ->condition('content_type', $entity_type)
        ->condition('content_id', $entity_ids, 'IN');
    }
    else {
      $query = db_select('flagging', 'fc')
        ->condition('entity_type', $entity_type)
        ->condition('entity_id', $entity_ids, 'IN');
    }

    $query->fields('fc')
      ->condition('fid', array_keys($fids), 'IN')
      ->condition('fc.uid', $subscribe_options['last uid'], '>')
      ->orderBy('fc.uid', 'ASC');

    if ($range) {
      $query->range(0, $range);
      // If we're mpt notifying blocked users, we need to take this into account
      // in this query so that the range is accurate.
      if (empty($subscribe_options['notify blocked users'])) {
        $query->join('users', 'users', 'users.uid = fc.uid');
        $query->condition('users.status', '1', '=');
      }
    }

    $result = $query->execute();

    foreach ($result as $row) {

      $uids[$row->uid] = !empty($uids[$row->uid]) ? $uids[$row->uid] : array('notifiers' => array());
      // Register the flag name.
      $flag_name = $fids[$row->fid];
      $uids[$row->uid]['flags'][] = $flag_name;

      if ($range) {
        --$range;
        if ($range == 0) {
          // We've reach the requested item.
          return $uids;
        }
      }
    }
  }

  return $uids;
}

/**
 * Get Message subscribe related flags.
 *
 * Return Flags related to message subscribe using a name convention --
 * the flag name should start with "subscribe_".
 *
 * @param $content_type
 *   Optional. The type of content for which to load the flags. Usually 'node'.
 * @param $content_subtype
 *   Optional. The node type for which to load the flags.
 * @param $account
 *   Optional. The user account to filter available flags. If not set, all
 *   flags for will this node will be returned.
 * @param $reset
 *   Optional. Reset the internal query cache.
 *
 * @return \Drupal\flag\FlagInterface[] $flags
 *   An array of the structure [fid] = flag_object.
 *
 * @see flag_get_flags()
 */
function message_subscribe_flag_get_flags($content_type = NULL, $content_subtype = NULL, $account = NULL, $reset = FALSE) {
  $flags = \Drupal::service('flag')->getFlags($content_type, $content_subtype, $account);
  $ms_flags = array();
  $prefix = \Drupal::config('message_subscribe.settings')->get('flag_prefix') . '_';
  foreach ($flags as $flag_name => $flag) {
    // Check that the flag is using name convention.
    if (strpos($flag_name, $prefix) === 0) {
      $ms_flags[$flag_name] = $flag;
    }
  }

  return $ms_flags;
}

/**
 * Implements hook_cron_queue_info().
 */
function message_subscribe_cron_queue_info() {
  $items['message_subscribe'] = array(
    'title' => t('Message subscribe'),
    'worker callback' => 'message_subscribe_queue_worker',
  );
  return $items;
}

/**
 * Queue API worker; Process a queue item.
 *
 * The item holds the Message ID, and user ID of the last user the email
 * was sent to.
 */
function message_subscribe_queue_worker($data, $end_time = FALSE) {
  extract($data);

  $entity = entity_load_single($entity_type, $entity_id);
  if (!$entity) {
    // Abort if the entity could not be loaded to avoid errors.
    return;
  }
  if (!$message = message_load($mid)) {
    // Abort if the message has been deleted to avoid errors.
    return;
  }
  $subscribe_options['queue'] = TRUE;

  message_subscribe_send_message($entity_type, $entity, $message, $notify_options, $subscribe_options, $context);
}
